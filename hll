
// // string reverse(string s, int size){
// //     int i;
// //     for(i=0;i<size;i=i+1){
// //         char temp1= s[i];
// //         char temp2 = s[size-i-1];
// //         s[i]=temp2;
// //         s[size-i-1]=temp1;
// //     }
// //     return s;
// // }

// string append(string p,int a,string q,int b){
//     string r = "";
//     int i;
//     for(i=0;i<a;i=i+1){
//         r[i]=p[i];
//         typeof r;
//         typeof p;
//     }
//     for(i=0;i<b;i=i+1){
//         r[a+i] = q[i];
//     }
//     return r;
// }
 
// int main()
// {
//     // int a[2]={1,2};
//     // progout(a[1]);
//     // int t = a[1];
//     // progout(t);
//     string p = "PBS";
//     string q = "ABC";
//     // progout(s[1]);
//     string r = append(p,3,q,3);
//     progout(r);
// }

// // string f(){
// //     return "PBS";
// // }

//int x=5;
// //typeof x;
// void global(){
//     int x=5;
// }

// int main(){
//     global();
//     typeof x;
//     progout(x);
//     int y=5;
//     //progout(y);
//     return 0;
// }

void global(){
    int MEMORY_SIZE = 16384;
    int FREE_LIST_START = 2048;

    int NO_BLOCK = -1;

    int freeBlockStarts[14336];
    int freeBlockSizes[14336];
    int memory[16384];
    int FL_LENGTH = 1;
    int FL_NEXT ;
    FL_NEXT=FREE_LIST_START;
    char keyboard[8];
}



void init() {
    FL_LENGTH = 1;
    FL_NEXT = FREE_LIST_START;
    freeBlockStarts[0] = FREE_LIST_START;
    freeBlockSizes[0] = MEMORY_SIZE - FREE_LIST_START;
    int i;
    for (i = 0; i < 8; i++) {
        keyboard[i] = 0;
    }
}

int peek(int address) {
    if (address >= 0 && address < MEMORY_SIZE) {
        return memory[address];
    }
    return -1; 
}

void poke(int address, int value) {
    if (address >= 0 && address < MEMORY_SIZE) {
        memory[address] = value;
    }
}

int best_fit(int size) {
    int bestFitIndex = NO_BLOCK;
    int bestFitSize = MEMORY_SIZE;
    int i;
    for (i = 0; i < FL_LENGTH; i=i+1) {
        if (freeBlockSizes[i] >= size && freeBlockSizes[i] < bestFitSize) {
            bestFitSize = freeBlockSizes[i];
            bestFitIndex = i;
        }
    }

    return bestFitIndex;
}

void custom_sort() {
    int i;
    for (i = 0; i < FL_LENGTH - 1; i=i+1) {
        int j;
        for (j = i + 1; j < FL_LENGTH; j=j+1) {
            if (freeBlockStarts[i] > freeBlockStarts[j]) {
                int tempStart = freeBlockStarts[i];
                int tempSize = freeBlockSizes[i];
                freeBlockStarts[i] = freeBlockStarts[j];
                freeBlockSizes[i] = freeBlockSizes[j];
                freeBlockStarts[j] = tempStart;
                freeBlockSizes[j] = tempSize;
            }
        }
    }
}

int allocate(int size) {
    int bestFitIndex = best_fit(size);

    if (bestFitIndex != NO_BLOCK) {
        int allocatedStart = freeBlockStarts[bestFitIndex];

        if (freeBlockSizes[bestFitIndex] > size) {
            freeBlockStarts[FL_LENGTH] = allocatedStart + size;
            freeBlockSizes[FL_LENGTH] = freeBlockSizes[bestFitIndex] - size;
            FL_LENGTH = FL_LENGTH + 1;
        }

        if (bestFitIndex < FL_LENGTH - 1) {
            int i;
            for (i = bestFitIndex; i < FL_LENGTH - 1; i=i+1) {
                freeBlockStarts[i] = freeBlockStarts[i+1];
                freeBlockSizes[i] = freeBlockSizes[i+1];
            }
        }

        FL_LENGTH = FL_LENGTH - 1;

        return allocatedStart;
    }

    return NO_BLOCK; // Allocation failed
}

void deallocate(int start, int size) {
    freeBlockStarts[FL_LENGTH] = start;
    freeBlockSizes[FL_LENGTH] = size;
    FL_LENGTH = FL_LENGTH + 1;

    custom_sort();

    // Merge adjacent free blocks
    int i;
    for (i = 0; i < FL_LENGTH - 1; i=i+1) {
        if (freeBlockStarts[i] + freeBlockSizes[i] == freeBlockStarts[i + 1]) {
            freeBlockSizes[i] = freeBlockSizes[i] + freeBlockSizes[i + 1];
            int j;
            for(j = i+1; j < FL_LENGTH - 1; j=j+1) {
                freeBlockStarts[j] = freeBlockStarts[j+1];
                freeBlockSizes[j] = freeBlockSizes[j+1];
            }
            FL_LENGTH = FL_LENGTH - 1;
            i = i - 1;
        }
    }
}


char keyPressed() {
    return keyboard[0];
}

char readChar() {
    char key;
    while (keyPressed() == 0) {}
    key = keyPressed();
    while (keyPressed() != 0) {}
    //cout << key;   //print to screen
    return key;
}

string removeLastCharacter(string input) {
    if (input.length() == 0) {
        return input; // Return empty string if input is already empty
    }
    
    string result;
    for (int i = 0; i < input.length() - 1; i++) {
        result = result + input[i];
    }
    return result;
}

string readLine(string message) {
    string line;
    char c;

    //cout << message;
    c = readChar();
    while (c != '\n') {
        if (c == '\b') {
            if (line.length() != 0) {
                removeLastCharacter(line);
            }
        }
        else {
            line = line + c;
        }
        c = readChar();
    }

    return line;
}

int stoi(string str) {
    int result = 0;
    bool isNegative = false;
    int i = 0;

    if (str[0] == '-') {
        isNegative = true;
        // i = 1;
    }

    for (i=1; i < str.length(); i=i+1) {
        if (str[i] >= '0' && str[i] <= '9') {
            result = result * 10 + (str[i] - '0');
        } else {
            // Handle invalid characters here if needed
            // For simplicity, we'll just return 0 for invalid inputs
            return 0;
        }
    }

    if (isNegative) {
        result = -result;
    }

    return result;
}

int readInt(string message) {
    string line;
    line = readLine(message);
    return stoi(line);
}


int main() {
    global();
    init();
    return 0;
}
